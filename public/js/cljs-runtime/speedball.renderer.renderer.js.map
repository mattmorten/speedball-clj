{"version":3,"sources":["speedball/renderer/renderer.cljs"],"mappings":"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","names":["malli.instrument.instrument_BANG_","malli.core.function_schemas","speedball.renderer.renderer/render-player","game","player-n","player-has-ball","speedball.game.player_has_ball_QMARK_","player-doesnt-have-ball","cljs.core/not","player-on-top-of-ball","cljs.core._EQ_","speedball.game/player-position","speedball.game/ball-position","speedball.board/player-tile-holding-ball","speedball.board/player-tile","speedball.renderer.renderer/render-board","vec__18311","cljs.core.nth","ball-y","ball-x","G__18314","cljs.core/assoc-in","players","cljs.core/empty?","vec__18318","player","cljs.core/first","player-y","player-x","cljs.core/rest","malli.core._register_function_schema_BANG_","speedball.game/Game","speedball.board/Board","cljs.core/identity","var_args","G__18322","speedball.renderer.renderer/run-game","js/Error","game-atom","input","cljs.core/deref","state","cljs.core.apply","camera-mount","controller","ai-controllers","speedball.renderer.camera-mount/evaluate-camera-mount-for-game","speedball.controller/evaluate-control","speedball.controller/refresh-ai-controllers","ai-actions","speedball.controller/produce-ai-actions","speedball.game/wait-one-second","speedball.game/apply-all-actions","speedball.game/evaluate-game-for-goal","cljs.core.print","cljs.pprint.pprint","speedball.renderer.camera-mount/render-camera-mount","speedball.controller/closest-player-n-to-ball-on-controllers-team","cljs.core.dissoc","cljs.core.println","speedball.controller/player-n","speedball.game/move-player-in-game","speedball.game/player-picks-up-ball","speedball.game/player-drops-ball","speedball.renderer.camera-mount/track-ball","speedball.game/throw-ball","speedball.renderer.camera-mount/toggle-player-on-camera","speedball.renderer.renderer/new-game-state","speedball.game.new_game","speedball.renderer.camera-mount/new-camera-mount","speedball.controller/new-human-controller","speedball.controller/new-ai-controllers","speedball.player.new_player"],"sourcesContent":["(ns speedball.renderer.renderer\n  (:require [clojure.string :as str]\n            [clojure.pprint :as pprint]\n            [malli.core :as mc]\n            [malli.instrument :as mi]\n            [speedball.camera :as camera]\n            [speedball.renderer.camera-mount :as mount]\n            [speedball.core :as core]\n            [speedball.player :as player]\n            [speedball.game :as game]\n            [speedball.board :as board]\n            [speedball.controller :as controller]\n            [speedball.ball :as ball]\n            [speedball.physics :as physics]))\n\n(mi/instrument!)\n(mc/function-schemas)\n\n(defn render-player [game player-n]\n  (let [player-has-ball (-> game (game/player-has-ball? player-n))\n        player-doesnt-have-ball (not player-has-ball)\n        player-on-top-of-ball (= (game/player-position game player-n) (game/ball-position game))]\n    (cond\n      (and player-doesnt-have-ball player-on-top-of-ball) :j\n      player-has-ball (board/player-tile-holding-ball player-n)\n      player-doesnt-have-ball (board/player-tile player-n))))\n\n(defn render-board [game]\n  (let [[ball-y ball-x] (game/ball-position game)\n        player-has-ball (-> game (game/player-has-ball?))\n        player-doesnt-have-ball (not player-has-ball)\n        game (cond-> game\n                     player-doesnt-have-ball (assoc-in [:board ball-y ball-x] :o))\n        ;; Recursively render the players\n        game (loop [game game\n                    players (:players game)\n                    player-n 0]\n               (if (empty? players)\n                 game\n                 (let [player (first players)\n                       [player-y player-x] (:position player)\n                       game (assoc-in game [:board player-y player-x] (render-player game player-n))]\n                   (recur game (rest players) (inc player-n)))))]\n    (:board game)))\n\n(mc/=> render-board [:=> [:cat game/Game] board/Board])\n\n(defn run-game\n  ([game-atom input]\n   (let [state @game-atom]\n     (apply run-game input state)))\n  ([input game camera-mount controller ai-controllers]\n   (let [camera-mount (mount/evaluate-camera-mount-for-game camera-mount game)\n         controller (controller/evaluate-control controller game)\n         ai-controllers (controller/refresh-ai-controllers ai-controllers controller game)\n         ai-actions (controller/produce-ai-actions ai-controllers game)\n         game (game/wait-one-second game)\n         game (game/apply-all-actions game ai-actions)\n         game (game/evaluate-game-for-goal game)]\n\n     (print \"Board:\\n\")\n     (pprint/pprint (render-board game))\n     (print \"Camera View:\\n\")\n     (pprint/pprint (->> game render-board (mount/render-camera-mount camera-mount)))\n     (print \"Camera Mount:\\n\")\n     (pprint/pprint camera-mount)\n     (print \"Controller:\\n\")\n     (pprint/pprint controller)\n     (print \"AIs:\\n\")\n     (pprint/pprint ai-controllers)\n     (print \"AI actions taken:\\n\")\n     (pprint/pprint ai-actions)\n     (print \"Closest player-n:\\n\\t\")\n     (pprint/pprint (controller/closest-player-n-to-ball-on-controllers-team controller game))\n     (print \"Game:\\n\")\n     (pprint/pprint (dissoc game :board))\n     (print \"Enter a key:\\n\\t\")\n     (println \"(w|a|s|d: move, f: pick up ball, g: drop ball, h: throw, e: wait, c: toggle cam)\")\n     (let [player-n (controller/player-n controller game)]\n       (cond\n         (= input \"w\") [(game/move-player-in-game game player-n :north) camera-mount controller ai-controllers] ;; Increment state\n         (= input \"a\") [(game/move-player-in-game game player-n :west) camera-mount controller ai-controllers];; Increment state\n         (= input \"s\") [(game/move-player-in-game game player-n :south) camera-mount controller ai-controllers] ;; Increment state\n         (= input \"d\") [(game/move-player-in-game game player-n :east) camera-mount controller ai-controllers];; Increment state\n         (= input \"f\") [(game/player-picks-up-ball game player-n) camera-mount controller ai-controllers] ;; Increment state\n         (= input \"g\") [(game/player-drops-ball game player-n) (mount/track-ball camera-mount ) controller ai-controllers] ;; Incre)ment state\n         (= input \"h\") [(game/throw-ball game player-n) (mount/track-ball camera-mount) controller ai-controllers]\n         (= input \"e\") [game camera-mount controller ai-controllers]\n         (= input \"c\") [game (mount/toggle-player-on-camera camera-mount game) controller ai-controllers]\n\n         :else (do\n                 (println \"Invalid key. Try again.\")\n                 [game camera-mount controller ai-controllers])))))) ;; Continue with the current state\n\n(defn new-game-state\n  []\n  (let [game (game/new-game)\n        camera-mount (mount/new-camera-mount)\n        controller (controller/new-human-controller)\n        ;; Will always include one for the human controller, since he might lose the ball\n        ;; One for each actual player\n        ai-controllers (controller/new-ai-controllers game controller)]\n    [game camera-mount controller ai-controllers]))\n\n;(defn run-loop []\n;  (loop [game (game/new-game)\n;         camera-mount (mount/new-camera-mount)\n;         controller (controller/new-human-controller)\n;         ;; Will always include one for the human controller, since he might lose the ball\n;         ;; One for each actual player\n;         ai-controllers (controller/new-ai-controllers game controller)]\n;    ;; We will do this here simply because I don't want to repeat myself in all the `cond` below!!\n;    (let [camera-mount (mount/evaluate-camera-mount-for-game camera-mount game)\n;          ai-actions (controller/produce-ai-actions ai-controllers game)\n;          game (game/wait-one-second game)\n;          game (game/apply-all-actions game ai-actions)\n;          game (game/evaluate-game-for-goal game)\n;          controller (controller/evaluate-control controller game)]\n;      (print \"Board:\\n\")\n;      (pprint/pprint (render-board game))\n;      (print \"Camera View:\\n\")\n;      (pprint/pprint (->> game render-board (mount/render-camera-mount camera-mount)))\n;      (print \"Camera Mount:\\n\")\n;      (pprint/pprint camera-mount)\n;      (print \"Controller:\\n\")\n;      (pprint/pprint controller)\n;      (print \"AIs:\\n\")\n;      (pprint/pprint ai-controllers)\n;      (print \"AI actions taken:\\n\")\n;      (pprint/pprint ai-actions)\n;      (print \"Closest player-n:\\n\\t\")\n;      (pprint/pprint (controller/closest-player-n-to-ball-on-controllers-team controller game))\n;      (print \"Game:\\n\")\n;      (pprint/pprint (dissoc game :board))\n;      (print \"Enter a key:\\n\\t\")\n;      (println \"(w|a|s|d: move, f: pick up ball, g: drop ball, h: throw, e: wait, c: toggle cam)\")\n;      (let [input (str/trim (read-line))\n;            player-n (controller/player-n controller game)]\n;        (cond\n;          (= input \"x\") (do\n;                          (println \"Exiting loop.\")\n;                          nil) ;; Quit the loop\n;          (= input \"w\") (recur (game/move-player-in-game game player-n :north) camera-mount controller ai-controllers) ;; Increment state\n;          (= input \"a\") (recur (game/move-player-in-game game player-n :west) camera-mount controller ai-controllers);; Increment state\n;          (= input \"s\") (recur (game/move-player-in-game game player-n :south) camera-mount controller ai-controllers) ;; Increment state\n;          (= input \"d\") (recur (game/move-player-in-game game player-n :east) camera-mount controller ai-controllers);; Increment state\n;          (= input \"f\") (recur (game/player-picks-up-ball game player-n) camera-mount controller ai-controllers) ;; Increment state\n;          (= input \"g\") (recur (game/player-drops-ball game player-n) (mount/track-ball camera-mount ) controller ai-controllers) ;; Incre)ment state\n;          (= input \"h\") (recur (game/throw-ball game player-n) (mount/track-ball camera-mount) controller ai-controllers)\n;          (= input \"e\") (recur game camera-mount controller ai-controllers)\n;          (= input \"c\") (recur game (mount/toggle-player-on-camera camera-mount game) controller ai-controllers)\n;\n;          :else (do\n;                  (println \"Invalid key. Try again.\")\n;                  (recur game camera-mount controller ai-controllers))))))) ;; Continue with the current state\n\n\n(-> (game/new-game {:players [(player/new-player)\n                              (player/new-player {:position [0 3]})]})\n    (game/player-picks-up-ball 1)\n    (game/evaluate-game-for-goal)\n    (render-board))\n\n(-> (game/new-game)\n    (game/move-player-in-game 0 :east)\n    ;(game/player-picks-up-ball 0)\n    (game/move-player-in-game 0 :south)\n    (game/move-player-in-game 0 :south)\n    (game/move-player-in-game 2 :east)\n    ;(game/move-player-in-game 0 :east)\n    ;(game/player-picks-up-ball 0)\n    ;(game/player-drops-ball 0)\n    ;(game/move-player-in-game 0 :west )\n    ;(game/move-player-in-game 0 :east )\n    ;(game/player-picks-up-ball 0)\n    ;(game/move-player-in-game 0 :north )\n    ;(game/move-player-in-game 0 :north )\n    ;(game/move-player-in-game 0 :north )\n    ;(game/move-player-in-game 0 :north )\n    ;(game/evaluate-game-for-goal)\n    ;(game/move-player-in-game 0 :south )\n    ;(game/evaluate-game-for-goal)\n    ;(game/move-player-in-game 0 :north )\n    ;(game/evaluate-game-for-goal)\n    render-board\n\n    :board)\n;(move-player-in-game :east)\n;render\n;:board)\n"]}